# Process monitoring & Supervisor in Elixir

## Process - What is the process?

Process just is an isolated island(run a flow code with a owner heap) in Elixir world. Process run & managed by owner scheduler on ErlVM. It's like green thread/lightweight thread in other languages.

<!-- livebook:{"branch_parent_index":0} -->

## some common call fow for process

Some flow of process.

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
stateDiagram-v2
  [*] --> init
  init --> do_job
  do_job --> finish
  finish --> [*]
```

<!-- livebook:{"break_markdown":true} -->

```mermaid
stateDiagram-v2
  [*] --> init
  init --> loop
  loop --> loop
  loop --> finish
  finish --> [*]
```

<!-- livebook:{"break_markdown":true} -->

Process simple is a chain of functions(or loop function)

<!-- livebook:{"break_markdown":true} -->

Define module for example.

```elixir
defmodule Hello do
  # simple
  def print(msg) do
    IO.puts("#{inspect(self())}, #{msg}")
  end

  # loop
  def loop(n) when is_integer(n) and n > 0 do
    IO.puts("#{inspect(self())}, n = #{n}")

    # loop again in here
    loop(n - 1)
  end

  # exit loop condition
  def loop(_n) do
    IO.puts("#{inspect(self())}, exit.")
  end

  # state 
  def state(3 = n) do
    IO.puts("#{inspect(self())}, state: 3")

    state(n - 1)
  end

  def state(2 = n) do
    IO.puts("#{inspect(self())}, state: 2")

    state(n - 1)
  end

  def state(1) do
    IO.puts("#{inspect(self())}, state: 1 & exit")
  end

  def state(n) do
    IO.puts("#{inspect(self())}, state: #{inspect(n)}")
  end
end
```

Example first call flow

```elixir
a = fn msg ->
  Hello.print(msg)
end

b = fn ->
  a.("Xin chÃ o!")
end

# spawn(Hello, :print, ["hello by spawn/3"])
spawn(b)
```

Example for second flow

```elixir
spawn(fn -> Hello.state(5) end)
```

Example for third flow

```elixir
spawn(fn -> Hello.loop(5) end)
```

<!-- livebook:{"branch_parent_index":0} -->

## Communite between processes

How to communicate between processes?

Use `send` for sending a msg to other process.

Use `receive` for waiting (or get from message queue) a message from other processes

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
sequenceDiagram;
  process_1->>process_2: send a msg to start request
  process_2->>process_1: respond request
  process_2->>process_1: new event
  process_1->>process_1: send to myself
```

## How to monitor/control process

How to manage process?

How to know when process exit or process die?

Or how to restart process if it's died?

<!-- livebook:{"branch_parent_index":3} -->

## Link between proceses

Build on top of Erlang, Elixir support create a link between processes.

But what is the link? That a solid connection between two processes if a process is die then another process will die.

Use by start process with function `spawn_link/1`, `spawn_link/3`, `Process.spawn/2` & `Process.spawn/4` with option `:link` or call `Process.link/1` with `PID` after called spawn.

For unlink process we can use `Process.unlink/1`.

For get info about link of process we can use `Process.info/2` with option `:links`.

The idea in here, you can fail fast or shutdown all processes asap like a domino effect(chain reaction). Think you have thousands processes then want to fail together or exit asap.

```elixir
defmodule LetsCrash do
  def event_loop do
    receive do
      :crash ->
        raise "#{inspect(self())}, I'm out"

      :shutdown ->
        IO.puts("#{inspect(self())}, I'm shutting down...")

      {from, :ping} ->
        IO.puts("#{inspect(self())}, I got a ping msg from #{inspect(from)}")
        send(from, :pong)
        event_loop()

      msg ->
        IO.puts("#{inspect(self())}, Unknown msg: #{inspect(msg)}")
        event_loop()
    after
      1500 ->
        IO.puts("#{inspect(self())}, I'm fine")
        event_loop()
    end
  end

  def get_one_msg() do
    receive do
      msg ->
        IO.puts("#{inspect(self())}, got a msg: #{inspect(msg)}")
    end
  end

  def create_son do
    pid = spawn_link(&event_loop/0)
    Process.register(pid, :son)

    IO.puts("spawn son process done => #{inspect(pid)}")
  end

  def init do
    create_son()

    event_loop()
  end

  def create_parent do
    pid = spawn(&init/0)
    Process.register(pid, :parent)
    IO.puts("spawn parent process done => #{inspect(pid)}")

    pid
  end
end
```

Let's create `:parent` & `:son` process

```elixir
LetsCrash.create_parent()
```

Let's check `:parent` & `:son` processes.

```elixir
case Process.whereis(:parent) do
  nil ->
    IO.puts("parent process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end

case Process.whereis(:son) do
  nil ->
    IO.puts("son process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end
```

Get a test by send message to both processes

```elixir
send(:parent, {self(), :ping})
LetsCrash.get_one_msg()

send(:son, {self(), :ping})
LetsCrash.get_one_msg()
```

Let's us crash a process and see what happen.

```elixir
send(:parent, :crash)
```

Let's check processes again.

<!-- livebook:{"branch_parent_index":3} -->

## Monitor a process

In another hand, you want to know how process died or want to restart process if it die.

You can use monitor to receive a message when a monitored process die.

Some function for monitor process: `spawn_monitor/`, `spawn_monitor/3`, `Process.monitor/1`, `Process.spawn/2` & `Process.spawn/4` with option: `:monitor`

For demonitor: `Process.demonitor/2`

When monitored process is die other process will receive a message:

`{:DOWN, #Reference<...>, :process, #PID<...>, reason}`

<!-- livebook:{"break_markdown":true} -->

Module for demo:

```elixir
defmodule MonitorProcess do
  def event_loop do
    receive do
      :crash ->
        raise "#{inspect(self())}, I'm out"

      :shutdown ->
        IO.puts("#{inspect(self())}, I'm shutting down...")

      {from, :ping} ->
        IO.puts("#{inspect(self())}, I got a ping msg from #{inspect(from)}")
        send(from, :pong)
        event_loop()

      msg ->
        IO.puts("#{inspect(self())}, Unknown msg: #{inspect(msg)}")
        event_loop()
    after
      1500 ->
        IO.puts("#{inspect(self())}, I'm fine")
        event_loop()
    end
  end

  def get_one_msg() do
    receive do
      msg ->
        IO.puts("#{inspect(self())}, got a msg: #{inspect(msg)}")
    end
  end

  def create_son do
    # spawn with monitor
    {pid, ref} = spawn_monitor(&event_loop/0)
    Process.register(pid, :son_monitor)

    IO.puts("spawn son process done => #{inspect(pid)}, ref: #{inspect(ref)}")
  end

  def init do
    create_son()

    event_loop()
  end

  def create_parent do
    # normal spawn
    pid = spawn(&init/0)
    Process.register(pid, :parent_monitor)
    IO.puts("spawn parent process done => #{inspect(pid)}")

    pid
  end
end
```

Shutdown all processes:

```elixir
spawn(fn -> send(:son_monitor, :shutdown) end)
spawn(fn -> send(:parent_monitor, :shutdown) end)
```

Spawn parent & son process, parent process will monitor son process.

```elixir
MonitorProcess.create_parent()
```

We have registered parent & son process, let's check by process's name.

```elixir
case Process.whereis(:parent_monitor) do
  nil ->
    IO.puts("parent process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end

case Process.whereis(:son_monitor) do
  nil ->
    IO.puts("son process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end
```

Just another test. We test by send `:ping` message and get back a `:pong`

```elixir
send(:parent_monitor, {self(), :ping})
LetsCrash.get_one_msg()

send(:son_monitor, {self(), :ping})
LetsCrash.get_one_msg()
```

Let's crash son process.

```elixir
send(:son_monitor, :crash)
```

```elixir
send(:parent_monitor, :crash)
```

```elixir
send(:son_monitor, :shutdown)
```

<!-- livebook:{"branch_parent_index":3} -->

## Trap process

We can trap exit a process by function `Process.flag/2` & `Process.flag/3` with option `:trap_exit` and value `true`.

If process was set `:trap_exit` process(self or other process) will receive a message

` {:EXIT, from, reason}`

`:trap_exit` will ignore if procss was `:kill`

Function for example:

```elixir
fun = fn me ->
  receive do
    :stop ->
      IO.puts("I'm out, pid: #{inspect(self())}")

    {:trap, value} ->
      IO.puts("trap: #{inspect(value)}, pid: #{inspect(self())}")
      Process.flag(:trap_exit, value)
      me.(me)

    :raise ->
      raise "raise by #{inspect(self())}"

    {:EXIT, pid, reason} ->
      IO.puts("trapped a signal pid: #{inspect(pid)}, reason: #{inspect(reason)}")
      me.(me)

    unknown ->
      IO.puts("unknown msg: #{inspect(unknown)}, pid: #{inspect(self())}")
      me.(me)
  end
end
```

Try to kill process by `Process.exit/2` with reason `:normal`:

```elixir
pid =
  spawn(fn ->
    IO.puts("my pid: #{inspect(self())}")
    fun.(fun)
  end)

send(pid, {:trap, true})
Process.sleep(100)
Process.exit(pid, :normal)
Process.sleep(100)
IO.puts("#{inspect(pid)} is alive? =>  #{inspect(Process.alive?(pid))}")
```

Try to kill process by `Process.exit/2` with reason `:kill`:

```elixir
pid =
  spawn(fn ->
    IO.puts("my pid: #{inspect(self())}")
    fun.(fun)
  end)

send(pid, {:trap, true})
Process.sleep(100)
Process.exit(pid, :kill)
Process.sleep(100)
IO.puts("#{inspect(pid)} is alive? =>  #{inspect(Process.alive?(pid))}")
```

Try to kill process by `raise` an error in it process:

```elixir
pid =
  spawn(fn ->
    IO.puts("my pid: #{inspect(self())}")
    fun.(fun)
  end)

send(pid, {:trap, true})
send(pid, :raise)
Process.sleep(100)
IO.puts("#{inspect(pid)} is alive? =>  #{inspect(Process.alive?(pid))}")
```

## Build a simple supervisor

From link/monitor above we can build a supervisor.

The simple supervisor:

```elixir
defmodule MySup do
  ### API ###
  def start(name, childs, opts) when is_atom(name) and is_list(childs) and is_map(opts) do
    # start supervisor process.
    pid = spawn(__MODULE__, :init, [{name, childs, opts}])

    {:ok, pid}
  end

  def stop(name) do
    send(name, {self(), :stop})

    receive do
      :stop_ok ->
        :ok
    end
  end

  ### Init function ###
  def init({name, children, opts} = config) do
    Process.register(self(), name)
    IO.puts("started supervisor with name #{inspect(name)}")

    result = start_children(children, opts)
    IO.puts("Started #{inspect(map_size(result))}")

    # go to monitor stage
    sup_loop(result, config)
  end

  ### Private functions ###
  defp sup_loop(
         children,
         {name, child_param, %{strategy: strategy, restart: restart} = opts} = config
       ) do
    receive do
      {from, :stop} ->
        IO.puts("stop supervisor: #{inspect(name)}")
        # stop all child by kill

        send(from, :stop_ok)

      # handle child down
      {:DOWN, ref, :process, pid, reason} ->
        IO.puts(
          "Sup #{inspect(name)}, process die pid: #{inspect(pid)}, reason: #{inspect(reason)}"
        )

        case strategy do
          :standalone ->
            case {restart, reason} do
              # doesn't restart child that force kill
              {:always, :kil} ->
                IO.puts(
                  "Sup #{inspect(name)}, strategy: #{inspect(strategy)}, ignore restart killed child, child pid: #{inspect(pid)}"
                )

                sup_loop(Map.delete(children, ref), config)

              # doesn't restart child that force kill
              {:failed, :normal} ->
                IO.puts(
                  "Sup #{inspect(name)}, strategy: #{inspect(strategy)}, ignore normal shutdown child, child pid: #{inspect(pid)}"
                )

                sup_loop(Map.delete(children, ref), config)

              # restart child
              _ ->
                {module, fun, args} = Map.get(children, ref)
                {new_pid, new_ref} = spawn_monitor(module, fun, args)

                IO.puts(
                  "Sup #{inspect(name)}, strategy: #{inspect(strategy)}, restart child, child's old pid: #{inspect(pid)}, new pid: #{inspect(new_pid)}"
                )

                children =
                  children
                  |> Map.delete(ref)
                  |> Map.put(new_ref, {module, fun, args})

                sup_loop(children, config)
            end

          #  
          :group ->
            IO.puts("Sup #{inspect(name)}, group children die, restart now")
            children = start_children(child_param, opts)

            sup_loop(children, config)
        end

      unknown ->
        IO.puts("unknown msg: #{inspect(unknown)}")
        sup_loop(children, config)
    end
  end

  defp start_children(childs, %{strategy: :standalone} = opts) do
    start_children(childs, opts, %{})
  end

  defp start_children(childs, %{strategy: :group} = opts) do
    start_children(childs, opts, %{lastPid: nil})
  end

  defp start_children([], _opts, result) do
    result
  end

  # start child run standalone
  defp start_children(
         [{module, fun, args} = child | rest],
         %{strategy: :standalone} = opts,
         result
       ) do
    {_, ref} = spawn_monitor(module, fun, args)

    start_children(rest, opts, Map.put(result, ref, child))
  end

  # start child run in group. if one fail other will be restarted
  defp start_children([{module, fun, args}], %{strategy: :group} = opts, result) do
    # for group children, all will die together we need monitor one
    {_, ref} = spawn_monitor(module, fun, args)

    start_children([], opts, Map.put(result, :group, ref))
  end

  defp start_children([child | rest], %{strategy: :group} = opts, %{lastPid: lastPid} = result) do
    pid = spawn(fn -> spawn_child_link(lastPid, child) end)

    start_children(rest, opts, Map.put(result, :lastPid, pid))
  end

  # support link a chain
  defp spawn_child_link(lastPid, {module, fun, args}) do
    if lastPid != nil do
      Process.link(lastPid)
    end

    apply(module, fun, args)
  end
end
```

A simple module for demo:

```elixir
defmodule SimpleLoop do
  def loop() do
    receive do
      :stop ->
        :ok

      :raise ->
        raise "raised by #{inspect(self())}"

      {from, :ping} ->
        send(from, :pong)
        loop()
    end
  end

  def init(name) do
    Process.register(self(), name)
    IO.puts("started child #{inspect(name)}, pid: #{inspect(self())}")

    loop()
  end
end
```

Start supervisor:

```elixir
MySup.start(
  :my_sup,
  [
    {SimpleLoop, :init, [:child_1]},
    {SimpleLoop, :init, [:child_2]}
  ],
  %{strategy: :group, restart: :failed}
)
```

```elixir
send(:child_1, :ping)

receive do
  msg -> IO.puts("#{inspect(msg)}")
after
  1000 ->
    IO.puts("no :pong return")
end
```

```elixir
Process.alive?(Process.whereis(:child_1))
```

```elixir
send(:child_1, :raise)
```

```elixir
MySup.stop(:my_sup)
```
