# Process monitoring & Supervisor in Elixir

## Process - What is the process?

Process just is an isolated island(run a flow code with a owner heap) in Elixir world. Process run & managed by owner scheduler on ErlVM. It's like green thread/lightweight thread in other languages.

<!-- livebook:{"branch_parent_index":0} -->

## some common call fow for process

Some flow of process.

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
stateDiagram-v2
  [*] --> init
  init --> do_job
  do_job --> finish
  finish --> [*]
```

<!-- livebook:{"break_markdown":true} -->

```mermaid
stateDiagram-v2
  [*] --> init
  init --> loop
  loop --> loop
  loop --> finish
  finish --> [*]
```

<!-- livebook:{"break_markdown":true} -->

Process simple is a chain of functions(or loop function)

<!-- livebook:{"break_markdown":true} -->

Define module for example.

```elixir
defmodule Hello do
  # simple
  def print(msg) do
    IO.puts("#{inspect(self())}, #{msg}")
  end

  # loop
  def loop(n) when is_integer(n) and n > 0 do
    IO.puts("#{inspect(self())}, n = #{n}")

    # loop again in here
    loop(n - 1)
  end

  # exit loop condition
  def loop(_n) do
    IO.puts("#{inspect(self())}, exit.")
  end

  # state 
  def state(3 = n) do
    IO.puts("#{inspect(self())}, state: 3")

    state(n - 1)
  end

  def state(2 = n) do
    IO.puts("#{inspect(self())}, state: 2")

    state(n - 1)
  end

  def state(1) do
    IO.puts("#{inspect(self())}, state: 1 & exit")
  end

  def state(n) do
    IO.puts("#{inspect(self())}, state: #{inspect(n)}")
  end
end
```

Example first call flow

```elixir
a = fn msg ->
  Hello.print(msg)
end

b = fn ->
  a.("Xin chÃ o!")
end

# spawn(Hello, :print, ["hello by spawn/3"])
spawn(b)
```

Example for second flow

```elixir
spawn(fn -> Hello.state(5) end)
```

Example for third flow

```elixir
spawn(fn -> Hello.loop(5) end)
```

<!-- livebook:{"branch_parent_index":0} -->

## Communite between processes

How to communicate between processes?

Use `send` for sending a msg to other process.

Use `receive` for waiting (or get from message queue) a message from other processes

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
sequenceDiagram;
  process_1->>process_2: send a msg to start request
  process_2->>process_1: respond request
  process_2->>process_1: new event
  process_1->>process_1: send to myself
```

## How to monitor process

How to manage process?

How to know when process exit or process die?

Or how to restart process if it's died?

<!-- livebook:{"branch_parent_index":3} -->

## Link between proceses

Build on top of Erlang, Elixir support create a link between processes.

But what is the link? That a solid connection between two processes if a process is die then another process will die.

Use by start process with function `spawn_link/1`, `spawn_link/3`, `Process.spawn/2` & `Process.spawn/4` with option `:link` or call `Process.link/1` with `PID` after called spawn.

For unlink process we can use `Process.unlink/1`.

For get info about link of process we can use `Process.info/2` with option `:links`.

The idea in here, you can fail fast or shutdown all processes asap like a domino effect(chain reaction). Think you have thousands processes then want to fail together or exit asap.

```elixir
defmodule LetsCrash do
  def event_loop do
    receive do
      :crash ->
        raise "#{inspect(self())}, I'm out"

      :shutdown ->
        IO.puts("#{inspect(self())}, I'm shutting down...")

      {from, :ping} ->
        IO.puts("#{inspect(self())}, I got a ping msg from #{inspect(from)}")
        send(from, :pong)
        event_loop()

      msg ->
        IO.puts("#{inspect(self())}, Unknown msg: #{inspect(msg)}")
        event_loop()
    after
      1500 ->
        IO.puts("#{inspect(self())}, I'm fine")
        event_loop()
    end
  end

  def get_one_msg() do
    receive do
      msg ->
        IO.puts("#{inspect(self())}, got a msg: #{inspect(msg)}")
    end
  end

  def create_son do
    pid = spawn_link(&event_loop/0)
    Process.register(pid, :son)

    IO.puts("spawn son process done => #{inspect(pid)}")
  end

  def init do
    create_son()

    event_loop()
  end

  def create_parent do
    pid = spawn(&init/0)
    Process.register(pid, :parent)
    IO.puts("spawn parent process done => #{inspect(pid)}")

    pid
  end
end
```

Let's create `:parent` & `:son` process

```elixir
LetsCrash.create_parent()
```

Let's check `:parent` & `:son` processes.

```elixir
case Process.whereis(:parent) do
  nil ->
    IO.puts("parent process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end

case Process.whereis(:son) do
  nil ->
    IO.puts("son process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end
```

Get a test by send message to both processes

```elixir
send(:parent, {self(), :ping})
LetsCrash.get_one_msg()

send(:son, {self(), :ping})
LetsCrash.get_one_msg()
```

Let's us crash a process and see what happen.

```elixir
send(:parent, :crash)
```

Let's check processes again.

<!-- livebook:{"branch_parent_index":3} -->

## Monitor a process

In another hand, you want to know how process died or want to restart process if it die.

You can use monitor to receive a message when a monitored process die.

Some function for monitor process: `spawn_monitor/`, `spawn_monitor/3`, `Process.monitor/1`, `Process.spawn/2` & `Process.spawn/4` with option: `:monitor`

For demonitor: `Process.demonitor/2`

When monitored process is die other process will receive a message:

`{:DOWN, #Reference<...>, :process, #PID<...>, reason}`

```elixir
defmodule MonitorProcess do
  def event_loop do
    receive do
      :crash ->
        raise "#{inspect(self())}, I'm out"

      :shutdown ->
        IO.puts("#{inspect(self())}, I'm shutting down...")

      {from, :ping} ->
        IO.puts("#{inspect(self())}, I got a ping msg from #{inspect(from)}")
        send(from, :pong)
        event_loop()

      msg ->
        IO.puts("#{inspect(self())}, Unknown msg: #{inspect(msg)}")
        event_loop()
    after
      1500 ->
        IO.puts("#{inspect(self())}, I'm fine")
        event_loop()
    end
  end

  def get_one_msg() do
    receive do
      msg ->
        IO.puts("#{inspect(self())}, got a msg: #{inspect(msg)}")
    end
  end

  def create_son do
    # spawn with monitor
    {pid, ref} = spawn_monitor(&event_loop/0)
    Process.register(pid, :son_monitor)

    IO.puts("spawn son process done => #{inspect(pid)}, ref: #{inspect(ref)}")
  end

  def init do
    create_son()

    event_loop()
  end

  def create_parent do
    # normal spawn
    pid = spawn(&init/0)
    Process.register(pid, :parent_monitor)
    IO.puts("spawn parent process done => #{inspect(pid)}")

    pid
  end
end
```

```elixir
MonitorProcess.create_parent()
```

```elixir
case Process.whereis(:parent_monitor) do
  nil ->
    IO.puts("parent process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end

case Process.whereis(:son_monitor) do
  nil ->
    IO.puts("son process is death")

  pid ->
    result = Process.alive?(pid)
    IO.puts(" #{inspect(pid)} is alive? #{inspect(result)}")
end
```

```elixir
send(:parent_monitor, {self(), :ping})
LetsCrash.get_one_msg()

send(:son_monitor, {self(), :ping})
LetsCrash.get_one_msg()
```

```elixir
send(:son_monitor, :crash)
```

```elixir
send(:parent_monitor, :crash)
```
